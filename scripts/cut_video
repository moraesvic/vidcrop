#!/bin/bash

if [ $# -ne 3 ] ; then
	echo "$0: ERROR! wrong usage"
	exit 1
fi

if [ ! -f "$1" ] ; then
	echo "$0: ERROR! \"$1\" is not a file"
	exit 1
fi

time_regex="^[0-9]{1,2}:[0-9]{2}:[0-9]{2}$"

if [[ ! $2 =~ $time_regex ]] ; then
	echo "$0: ERROR! \"$2\" is not a valid time"
	exit 1
fi

if [[ ! $3 =~ $time_regex ]] ; then
	echo "$0: ERROR! \"$3\" is not a valid time"
	exit 1
fi

input_file="$1"
start_time="$2"
end_time="$3"

file_without_path="${input_file##*/}"
path_to_file="${input_file%/*}"

out_dir="out"
out_dir_full_path="${path_to_file}/${out_dir}"

if [ ! -d "$out_dir_full_path" ] ; then
	echo "$out_dir_full_path does not yet exist... creating..."
	mkdir -p "$out_dir_full_path" || ( >&2 echo "$0: ERROR! Could not create path to output files! exiting"  ; exit 1 )
fi

extension="${file_without_path##*.}"
timestamp=$(date +"%d_%b__%T")

existing=$(

cd $out_dir_full_path 
ls -1 ${file_without_path%.*}.* 2> /dev/null |
wc -l

)
new_index=$((existing + 1))

output_file="${out_dir_full_path}/${file_without_path%.*}.${new_index}__${start_time}_${end_time}.$extension"

echo -e "Success! will output to $output_file"

log_file="${out_dir_full_path}/${0}.log"
echo "${timestamp} : creating ${output_file}" >> "$log_file"

################################################################################
# The error was in the following line
# The problem is ffmpeg also reads data from stdin, thus consuming
# data that was meant for "read"
# The solution lies in setting stdin from /dev/null
#
# https://unix.stackexchange.com/questions/241535/problem-with-ffmpeg-in-bash-loop
#

ffmpeg -loglevel warning -ss "${start_time}" -to "${end_time}" -i "${input_file}" -c copy "${output_file}" < /dev/null

